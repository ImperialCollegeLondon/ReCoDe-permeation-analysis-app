# Scientific Visualisation Implementation

This document explains how the scientific visualisations are implemented in the application. 

## Overview

The `visualisation.py` file provides specialised plotting functions to help interpret time lag analysis results. The visualisations in this application are implemented using Matplotlib.

## Core Visualisation Functions

### 1. Time Lag Analysis Plot

The `plot_time_lag_analysis` function plots the cumulative flux (y-axis) against time (x-axis) which is used to calculate the time lag $(\theta)$, as previously shown in [`04-TimelagAnalysis-Implementation`](04-TimelagAnalysis-Implementation.md). This plot is importnant for validating the time lag analysis.

The core features are:

- **Experimental Data**: The cumulative flux based on raw data is plotted as a function of time.
- **Steady-State Fit**: A linear fit to the steady-state portion of the curve.
- **Extrapolation**: An extension of the steady-state line to earlier times. This provides visual determination for time lag $(\theta)$.

<!-- TODO add sample plot -->

### 2. Concentration Profile Plot

The `plot_concentration_profile` function plots the spatial distribution of gas concentration (y-axis) along the position within the membrane (x-axis) at different times (colour gradient). This helps with the intuitive understanding of the gas diffusion process within the membrane and validate that the PDE solver is correctly implementing the physical model.

The core features are:

- **Multiple Time Points**: Shows several snapshots of the concentration profile during the diffusion process.
- **Spatial Dimension**: Displays concentration as a function of position within the membrane.
- **Colour Gradient**: Uses a color gradient to indicate time progression.
- **Boundary Conditions**: Clearly shows the fixed boundary conditions ($C = C_{eq}$ at `x = 0` and $C = 0$ at $x = L$).

<!-- TODO add sample plot -->

### 3. Flux Comparison Visualisation

The `plot_flux_comparison` function plots flux (y-axis) against time (x-axis), comparing experimental data and theoretical predictions from the PDE solver. This demonstrates how well the model reproduces the data.

The core features are:

- **Theoretical Curve**: Displayed as a continuous line to represent the model prediction.
- **Experimental Data**: Plotted as points to show the raw measurements.

<!-- TODO add sample plot -->

## Consistent Styling with `set_plot_style()`

The `set_plot_style()` function plays a crucial role in maintaining visual consistency across all plots generated by the application. It is typically called at the beginning of each plot function to set consistent plot styling.

```python
def set_plot_style():
    """Set the default plot style for consistent visualization."""
    plt.style.use('seaborn-v0_8-whitegrid')
    
    # Define consistent plot aesthetics
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = ['Arial', 'DejaVu Sans', 'Liberation Sans', 'Bitstream Vera Sans', 'sans-serif']
    plt.rcParams['axes.labelsize'] = 12
    plt.rcParams['axes.titlesize'] = 14
    plt.rcParams['xtick.labelsize'] = 10
    plt.rcParams['ytick.labelsize'] = 10
    plt.rcParams['legend.fontsize'] = 10
    plt.rcParams['figure.titlesize'] = 16
    
    # Define color schemes
    plt.rcParams['axes.prop_cycle'] = plt.cycler(color=[
        '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', 
        '#CA9161', '#FBAFE4', '#949494', '#ECE133', '#56B4E9'
    ])
```

### Key Functions of `set_plot_style()`

1. **Base Style Setting**: Establishes a clean, professional base style using `seaborn-v0_8-whitegrid`, which provides a good foundation for scientific visualisation

2. **Font Configuration**: 
   - Sets sans-serif fonts for better readability on screens and in printed publications
   - Establishes a font fallback hierarchy to ensure consistent appearance across platforms

3. **Size Hierarchy**:
   - Creates a clear visual hierarchy with different sizes for titles, axes labels, and tick labels
   - Optimizes font sizes for readability while maintaining professional appearance

4. **Color Scheme**:
   - Implements a colorblind-friendly, visually distinct palette
   - Uses colors that reproduce well in print and remain distinguishable in grayscale

### Benefits of Centralized Style Management

By centralizing styling decisions in a single function, the implementation achieves several important goals:

1. **Consistency**: All plots share the same visual language, creating a cohesive look and feel
2. **Maintainability**: Style changes can be made in one location rather than throughout the codebase
3. **Professionalism**: Ensures all visualisations meet publication standards
4. **Accessibility**: The chosen color scheme and font sizes improve readability for users with visual impairments

### Customizing Predefined Styles

The application also provides a dictionary of standard figure sizes for different plot types, complementing the `set_plot_style()` function:

```python
figsize_dict = {
    'default': (8, 6),    # Standard figure size
    'wide': (12, 6),      # Wide format for time series
    'square': (8, 8),     # Square format for correlation plots
    'tall': (6, 8),       # Tall format for vertical data
    'arrhenius': (12, 5), # Special format for Arrhenius plots
    'comparison': (10, 8) # Format for multi-panel comparison plots
}
```

This dictionary works in conjunction with `set_plot_style()` to provide both consistent styling and appropriate dimensions:

```python
# Apply style and use a predefined figure size
set_plot_style()
fig, ax = plt.subplots(figsize=figsize_dict['wide'])
```

By combining these elements, the application ensures that all visualisations maintain a professional, consistent appearance regardless of which function generates them or which part of the application displays them.

## Visualisation Customization and Style

The module includes functions for setting consistent visualisation styles:

```python
def set_plot_style():
    """Set the default plot style for consistent visualization."""
    plt.style.use('seaborn-v0_8-whitegrid')
    
    # Define consistent plot aesthetics
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = ['Arial', 'DejaVu Sans', 'Liberation Sans', 'Bitstream Vera Sans', 'sans-serif']
    plt.rcParams['axes.labelsize'] = 12
    plt.rcParams['axes.titlesize'] = 14
    plt.rcParams['xtick.labelsize'] = 10
    plt.rcParams['ytick.labelsize'] = 10
    plt.rcParams['legend.fontsize'] = 10
    plt.rcParams['figure.titlesize'] = 16
    
    # Define color schemes
    plt.rcParams['axes.prop_cycle'] = plt.cycler(color=[
        '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', 
        '#CA9161', '#FBAFE4', '#949494', '#ECE133', '#56B4E9'
    ])
```

These style settings ensure that all visualisations have a consistent and professional appearance, which is important for:
- Creating publication-quality figures
- Maintaining visual consistency across different analyses
- Optimizing readability and clarity of scientific data presentation

## Usage Example

```python
# Set consistent style for all plots
set_plot_style()

# Create and customize a time lag analysis plot
fig, ax = plt.subplots(figsize=figsize_dict['default'])
plot_time_lag_analysis(data_df, 500, 0.00025, -0.12, fig, ax)

# Add custom elements if needed
ax.set_xlim(0, 2000)
ax.set_ylim(-0.05, 0.4)
ax.annotate('Steady-state region', xy=(1200, 0.2), xytext=(1000, 0.3),
            arrowprops=dict(arrowstyle='->'))

# Save the figure
plt.savefig('custom_timelag_plot.png', dpi=300, bbox_inches='tight')
```

This example demonstrates how to:
1. Apply consistent styling
2. Create a basic visualisation
3. Customize it with additional elements
4. Save the result to a file

## Advantages of this Implementation

The visualisation implementation in this application offers several advantages:

1. **Separation of Concerns**: Visualisation logic is separated from analysis code
2. **Consistent Styling**: All plots have a consistent, professional appearance
3. **Customizability**: Functions accept optional figure and axes objects for further customization
4. **Scientific Focus**: Visualisations are optimized for scientific interpretation
5. **Integration**: Seamlessly integrates with the analysis workflow